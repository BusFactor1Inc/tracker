;; -*- mode: lisp -*-

(defview *Pattern-edit-view
    model "pattern"
    contains "ChannelView"

    init (lambda ()
           (this.pattern.each (lambda (channel)
                                (let ((view (new (*View *Channel-view channel))))
                                  (this.add view)
                                  ((@ view render)))) this)
           (this.create 'current-channel-view (this.at 0))
           ((@ (this.at 0) selected) t)

           (this.on :channel-select (lambda (e)
                                      ((@ ((@ this current-channel-view)) selected) f)
                                      ((@ this current-channel-view) e.value)
                                      ((@ ((@ this current-channel-view)) selected) t)))

           (this.create 'current-note-view ((@ (this.at 0) at) 0))
           ((@ ((@ (this.at 0) at) 0) selected) t)

           (this.on :note-select (lambda (e)
                                   ((@ ((@ this current-note-view)) selected) f)
                                   ((@ this current-note-view) e.value)
                                   ((@ ((@ this current-note-view)) selected) t)))

           ;; this is a bit hoakey, but rendering optimization makes it so
           ;; we know :add and :removed come before the :modified message
           ;; so we can store the values and dispatch to more specifiec
           ;; view rebuilding functions based on what is added or removed
           (this.pattern.on :add (lambda (e)
                                   (setf this.added e.value)) this)
           (this.pattern.on :remove (lambda (e)
                                      (setf this.removed e.value)) this)
           (this.pattern.on :modified (@ this rebuild-views) this))

    add-view (lambda ()
               (let ((i ((@ this pattern index-of) this.added))
                     (view (new (*View *Channel-view this.added))))
                 ((@ this insert-at) i view)
                 ((@ view render))
                 (setf this.added nil)))
                 
    remove-view (lambda ()
                  (let ((view (this.find (lambda (channel-view)
                                           (= (@ channel-view channel) this.removed)))))
                    (this.remove view)
                    (setf this.removed nil)))

    reorder-views (lambda ()
                    (let ((views (this.map (lambda (e) e))))
                      (this.clear)
                      (let ((self this))
                        (this.pattern.each
                         (lambda (channel)
                           (dolist (view views)
                             (if (= (@ view channel) channel)
                                 (self.add view t))))))))

    rebuild-views (lambda (e)
                    (if this.added
                        ((@ this add-view))
                        (if this.removed
                            ((@ this remove-view) this.removed)
                            ((@ this reorder-views))))
                    (this.render))

    render (lambda ()
             (this.$el.html (this.map
                             (lambda (channel-view)
                               (@ channel-view $el))))))

(defview *Pattern-mode-line-view
    model "pattern"
    init (lambda (model)
           (this.pattern.on "change:name" this.render this))
    render (lambda ()
             ((@ this $el html) ((@ this pattern name)))))

(defview *Pattern-view
    model "pattern"
    init (lambda (model)
           (this.create 'editor (new (*View *Pattern-edit-view this.pattern)))
           (this.create 'mode-line (new (*View *Pattern-mode-line-view this.pattern)))
           )

    render (lambda ()
             (let ((html (array
                          (@ ((@ this editor)) $el)
                          (@ ((@ this mode-line)) $el)
                          )))
               ((@ this $el html) html))))
    
