;; -*- mode: lisp -*-
(load "macros.ps")
(load "utils.ps")

(defvar default-num-channels 4)
(defvar default-pattern-size 16)
(defvar default-num-patterns 4)

(defmodel *Note
    init (lambda (instrument pitch fx arg)
           (this.create :instrument instrument)
           (this.create :pitch pitch)
           (this.create :fx fx)
           (this.create :arg arg)
           ))

(defcontainer *Channel *Note
  init (lambda (name size)
         (this.create :size (or size default-pattern-size))
         (this.create :name name)
         (this.create :gain 128)
         (this.create :pan 128)
         (this.create :mute f)
         (this.create :solo f)

         (dotimes (i (this.size))
           (this.add (new (*Class *Note))))

         (this.on "change:size"
                  (lambda (e)
                    (let ((old-value e.value)
                          (new-value ((@ this size))))
                      (if (> old-value new-value)
                          (this.shrink old-value new-value)
                          (if (< old-value new-value)
                              (this.grow old-value new-value)))
                      (unless (= old-value new-value)
                        (this.trigger :resize))))))

  shrink (lambda (old-value new-value)
           (let ((to-remove (array))
                 (index ((@ this size))))
             (dotimes (i (- old-value ((@ this size))))
               ((@ to-remove push) ((@ this at) index))
               (incf index))
             (dolist (e to-remove)
               (this.remove e t))))

  grow (lambda (old-value new-value)
         (dotimes (i (- new-value old-value))
           ((@ this insert-at) (1- (+ i old-value))
            (new (*Class *Note)) t))))

(defcontainer *Pattern *Channel
  init (lambda (name size)
         (this.create :name name)
         (this.create :size (or size default-pattern-size))
         (dotimes (i default-num-channels)
           (this.add (new (*Class *Channel i ((@ this size))))))

         (this.on :close-channel
                  (lambda (e)
                    (this.remove e.value)))
         (this.on :add-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (new (*Class *Channel "--" ((@ this size))))))))
         (this.on :copy-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (e.value.copy)))))
         (this.on :move-channel-left
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (> i 0)
                          (this.swap i (1- i))))))
         (this.on :move-channel-right
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (< i (- this.length 1))
                          (this.swap i (1+ i))))))

         (this.on "change:size" (lambda (e)
                                  (this.each (lambda (channel)
                                               ((@ channel size) ((@ this size)))))))
         ))

(defcontainer *Song *Pattern
  init (lambda (name size)
         (this.create 'size (or size default-num-patterns))
         (this.create 'name (or name index))
         (dotimes (i ((@ this size)))
           (this.add (new (*Class *Pattern i))))

         (this.on :close-pattern
                  (lambda (e)
                    (this.remove e.value)))
         (this.on :add-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (new (*Class *Pattern "--"))))))
         (this.on :copy-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (e.value.copy)))))
         (this.on :move-pattern-up
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (> i 0)
                          (this.swap i (1- i))))))
         (this.on :move-pattern-down
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (< i (- this.length 1))
                          (this.swap i (1+ i))))))
         ))

(defcontainer *App *Song
  init (lambda (name)
         (this.create 'name (or name "untitled"))
         (this.add (new (*Class *Song ((@ this name)))))))

(load "common-views.ps")
(load "note-view.ps")
(load "channel-view.ps")
(load "pattern-view.ps")
(load "song-view.ps")

(defview *Minibuffer-view
    model "app"
    render (lambda ()
             ((@ this $el html) "<input class='MinibufferEditorView' type='text'>")))


(defview *App-view
    model "app"
    contains '*Song-view
    init (lambda (model)
           (this.create 'minibuffer (new (*View *Minibuffer-view this.app)))
           (this.create 'song (new (*View *Song-view ((@ this app at) 0)))))
    render (lambda ()
             (let ((html (array
                          (@ ((@ this song)) $el)
                          (@ ((@ this minibuffer)) $el))))
               ((@ this $el html) html))))

(defvar app (new (*Class *App)))
((@ ($ document) ready)
 (lambda ()
   (let ((app-view (new (*View *App-view app))))
     ((@ ($ 'body) html) (@ app-view $el))
     ((@ ($ document) bind) 'click (lambda (e)
                                    ((@ ($ ".MinibufferEditorView") select)))))))
;     ((@ ($ document) bind) 'keydown (lambda (e)
;                                       (console.log (@ e char-code))))
   
