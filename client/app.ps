;; -*- mode: lisp -*-
(load "macros.ps")
(load "utils.ps")

(defvar default-num-channels 12)
(defvar default-pattern-length 16)

(defmodel *Note
    init (lambda (instrument pitch fx arg)
           (this.create :instrument instrument)
           (this.create :pitch pitch)
           (this.create :fx fx)
           (this.create :arg arg)
           ))

(defcontainer *Channel *Note
  init (lambda (name size)
         (this.create :size (or size default-pattern-length))
         (this.create :name name)
         (this.create :gain 128)
         (this.create :pan 128)
         (this.create :mute f)
         (this.create :solo f)

         (dotimes (i (this.size))
           (this.add (new (*Class *Note))))))

(defcontainer *Pattern *Channel
  init (lambda (name size)
         (this.create :name name)
         (this.create :size (or size default-pattern-length))
         (dotimes (i default-num-channels)
           (this.add (new (*Class *Channel i ((@ this size))))))

         (this.on :close-channel
                  (lambda (e)
                    (this.remove e.value)))
         (this.on :add-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (new (*Class *Channel "--"))))))
         (this.on :copy-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (e.value.copy)))))
         (this.on :move-channel-left
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (> i 0)
                          (this.swap i (1- i))))))
         (this.on :move-channel-right
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (< i (- this.length 1))
                          (this.swap i (1+ i))))))
         ))

(defcontainer *Song *Pattern
  init (lambda (name size)
         (this.create 'size (or size 1))
         (this.create 'name (or name index))
         (dotimes (i ((@ this size)))
           (this.add (new (*Class *Pattern i))))))

(defcontainer *App *Song
  init (lambda (name)
         (this.create 'name (or name "untitled"))
         (this.add (new (*Class *Song ((@ this name)))))))

(load "common-views.ps")
(load "note-view.ps")
(load "channel-view.ps")
(load "pattern-view.ps")

(defview *Minibuffer-view
    model "app"
    render (lambda ()
             ((@ this $el html) "<input class='MinibufferEditorView' type='text'>")))


(defview *Song-view
    model "song"
    contains '*Pattern-view
    init (lambda (model)
           ((@ this song each) (lambda (pattern)
                                 (this.add (new (*View *Pattern-view pattern)))) this))

    render (lambda ()
             ((@ this $el html) (this.map (lambda (pattern-view)
                                            (@ pattern-view $el))))))

(defview *App-view
    model "app"
    contains '*Song-view
    init (lambda (model)
           (this.create 'minibuffer (new (*View *Minibuffer-view this.app)))
           (this.create 'song (new (*View *Song-view ((@ this app at) 0)))))
    render (lambda ()
             (let ((html (array
                          (@ ((@ this song)) $el)
                          (@ ((@ this minibuffer)) $el))))
               ((@ this $el html) html))))

(defvar app (new (*Class *App)))
((@ ($ document) ready)
 (lambda ()
   (let ((app-view (new (*View *App-view app))))
     ((@ ($ 'body) html) (@ app-view $el))
     ((@ ($ document) bind) 'click (lambda (e)
                                    ((@ ($ ".MinibufferEditorView") select)))))))
;     ((@ ($ document) bind) 'keydown (lambda (e)
;                                       (console.log (@ e char-code))))
   
