;; -*- mode: lisp -*-
(load "macros.ps")
(load "utils.ps")

(defvar default-num-channels 4)
(defvar default-pattern-size 16)
(defvar default-num-patterns 4)
(defvar default-tempo 0x80)
(defvar default-tics-per-beat 6)

(defmodel *Note
    init (lambda (instrument pitch fx arg)
           (this.create :instrument instrument)
           (this.create :pitch pitch)
           (this.create :fx fx)
           (this.create :arg arg)
           ))

(defcontainer *Channel *Note
  init (lambda (name index size)
         (this.create :name name)
         (this.create :index index)
         (this.create :size (or size default-pattern-size))
         (this.create :gain 128)
         (this.create :pan 128)
         (this.create :mute f)
         (this.create :solo f)

         (dotimes (i (this.size))
           (this.add (new (*Class *Note))))

         (this.on "change:size"
                  (lambda (e)
                    (let ((old-value e.value)
                          (new-value ((@ this size))))
                      (if (> old-value new-value)
                          (this.shrink old-value new-value)
                          (if (< old-value new-value)
                              (this.grow old-value new-value)))
                      (unless (= old-value new-value)
                        (this.trigger :resize))))))

  shrink (lambda (old-value new-value)
           (let ((to-remove (array))
                 (index ((@ this size))))
             (dotimes (i (- old-value ((@ this size))))
               ((@ to-remove push) ((@ this at) index))
               (incf index))
             (dolist (e to-remove)
               (this.remove e t))))

  grow (lambda (old-value new-value)
         (dotimes (i (- new-value old-value))
           ((@ this insert-at) (1- (+ i old-value))
            (new (*Class *Note)) t))))

(defcontainer *Pattern *Channel
  init (lambda (name size)
         (this.create :name name)
         (this.create :size (or size default-pattern-size))
         (dotimes (i default-num-channels)
           (this.add (new (*Class *Channel (+ "Channel " i) i ((@ this size))))))

         (this.on :close-channel
                  (lambda (e)
                    (if (> this.length 1)
                      (let ((i ((@ this index-of) e.value)))
                        (this.remove e.value)
                        (do ((j i (incf j)))
                            ((= j this.length))
                          ((@ ((@ this at) j) index) j)))
                      (alert "I'm sorry Dave, but you can't delete the last channel."))))

         (this.on :add-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i)
                       (new (*Class *Channel (+ "New " i) (1+ i) ((@ this size)))))
                      (do ((j (1+ i) (incf j)))
                          ((= j this.length))
                        ((@ ((@ this at) j) index) j))
                      )))

         (this.on :copy-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value))
                          (new-channel (e.value.copy)))
                      ((@ new-channel index) (1+ i))
                      ((@ this insert-at) (1+ i) new-channel)
                      ((@ new-channel name) (+ ((@ e.value name)) " ⎘")))))

         (this.on :move-channel-left
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (when (> i 0)
                        (this.swap i (1- i))
                        ((@ ((@ this at) i) index) i)
                        ((@ e.value index) (1- i))))))

         (this.on :move-channel-right
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (when (< i (- this.length 1))
                        (this.swap i (1+ i))
                        ((@ ((@ this at) i) index) i)
                        ((@ e.value index) (1+ i))))))


         (this.on "change:size" (lambda (e)
                                  (this.each (lambda (channel)
                                               ((@ channel size) ((@ this size)))))))
         ))

(defcontainer *Song *Pattern
  init (lambda (name size tempo tics-per-beat gain pan)
         (this.create 'size (or size default-num-patterns))
         (this.create 'name (or name index))
         (this.create 'tempo (or tempo default-tempo))
         (this.create 'tics-per-beat (or tics-per-beat default-tics-per-beat))
         (this.create 'gain (or gain 128))
         (this.create 'pan (or pan 128))
         (dotimes (i ((@ this size)))
           (this.add (new (*Class *Pattern (+ "Pattern " i)))))

         (this.on :close-pattern
                  (lambda (e)
                    (if (> this.length 1)
                        (this.remove e.value)
                        (alert "I'm sorry Dave, but you can't delete the last pattern."))))
         (this.on :add-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) (new (*Class *Pattern "--"))))))
         (this.on :copy-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value))
                          (new-pattern (e.value.copy)))
                      ((@ this insert-at) (1+ i) new-pattern)
                      ((@ new-pattern name) (+ ((@ e.value name)) " ⎘")))))
         (this.on :link-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) e.value))))
         (this.on :move-pattern-up
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (> i 0)
                          (this.swap i (1- i))))))
         (this.on :move-pattern-down
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (< i (- this.length 1))
                          (this.swap i (1+ i))))))
         ))

(defcontainer *App *Song
  init (lambda (name)
         (this.create 'name (or name "untitled"))
         (this.add (new (*Class *Song ((@ this name)))))))

(load "common-views.ps")
(load "note-view.ps")
(load "channel-view.ps")
(load "pattern-view.ps")
(load "song-view.ps")
(load "tools-view.ps")

(defview *Minibuffer-view
    model "app"
    render (lambda ()
             ((@ this $el html) "<input class='MinibufferEditorView' type='text'>")))

(defview *App-view
    model "app"
    contains '*Song-view
    init (lambda (model)
           (this.create 'minibuffer (new (*View *Minibuffer-view this.app)))
           (this.create 'tools (new (*View *Tools-view this.app)))
           (this.create 'song (new (*View *Song-view ((@ this app at) 0)))))
    render (lambda ()
             (let ((html (array
                          (@ ((@ this song)) $el)
                          (@ ((@ this tools)) $el)
                          (@ ((@ this minibuffer)) $el))))
               ((@ this $el html) html))))

(defvar app (new (*Class *App)))
((@ ($ document) ready)
 (lambda ()
   (let ((app-view (new (*View *App-view app))))
     ((@ ($ 'body) html) (@ app-view $el))
     ((@ ($ document) bind) 'click (lambda (e)
                                     (unless (or (= (@ e target tag-name) "INPUT")
                                                 (= (@ e target tag-name) "TEXTAREA"))
                                       ((@ ($ ".MinibufferEditorView") select))))))))
;     ((@ ($ document) bind) 'keydown (lambda (e)
;                                       (console.log (@ e char-code))))
   
