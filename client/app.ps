;; -*- mode: lisp -*-
(load "macros.ps")
(load "utils.ps")

(defmodel *Options
    defaults (create
              default-song-name "untitled"
              default-pattern-name "Pattern"
              default-channel-name "Channel"
              default-num-channels 4
              default-pattern-size 16
              default-num-patterns 4
              default-tempo 0x80
              default-tics-per-beat 6
              default-gain 0x80
              default-pan 0x80))

(defmodel *Note
    init (lambda (instrument pitch fx arg)
           (this.create :instrument instrument)
           (this.create :pitch pitch)
           (this.create :fx fx)
           (this.create :arg arg)
           ))

(defcontainer *Channel *Note
  init (lambda (&optional
                  (name ((@ options default-channel-name)))
                  (index 0)
                  (size ((@ options default-pattern-size))))
         (this.create :name name)
         (this.create :index index)
         (this.create :size size)
         (this.create :gain 128)
         (this.create :pan 128)
         (this.create :mute f)
         (this.create :solo f)

         (dotimes (i (this.size))
           (this.add (new (*Class *Note))))

         (this.on "change:size"
                  (lambda (e)
                    (let ((old-value e.value)
                          (new-value ((@ this size))))
                      (if (> old-value new-value)
                          (this.shrink old-value new-value)
                          (if (< old-value new-value)
                              (this.grow old-value new-value)))
                      (unless (= old-value new-value)
                        (this.trigger :resize))))))

  shrink (lambda (old-value new-value)
           (let ((to-remove (array))
                 (index ((@ this size))))
             (dotimes (i (- old-value ((@ this size))))
               ((@ to-remove push) ((@ this at) index))
               (incf index))
             (dolist (e to-remove)
               (this.remove e t))))

  grow (lambda (old-value new-value)
         (dotimes (i (- new-value old-value))
           ((@ this insert-at) (1- (+ i old-value))
            (new (*Class *Note)) t))))

(defcontainer *Pattern *Channel
  init (lambda (&optional
                  (name ((@ options default-pattern-name)))
                  (size ((@ options default-pattern-size)))
                  (num-channels ((@ options default-num-channels))))
         (this.create :name name)
         (this.create :size size)
         (dotimes (i num-channels)
           (this.add (new (*Class *Channel (+ ((@ options default-channel-name)) " "  i)
                                  i ((@ this size))))))

         (this.on :close-channel
                  (lambda (e)
                    (if (> this.length 1)
                      (let ((i ((@ this index-of) e.value)))
                        (this.remove e.value)
                        (do ((j i (incf j)))
                            ((= j this.length))
                          ((@ ((@ this at) j) index) j)))
                      (alert "I'm sorry Dave, but you can't delete the last channel."))))

         (this.on :add-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i)
                       (new (*Class *Channel (+ ((@ options default-channel-name)) " "
                                                (+ this.length 1))
                                    (1+ i)
                                    ((@ this size)))))
                      (do ((j (1+ i) (incf j)))
                          ((= j this.length))
                        ((@ ((@ this at) j) index) j))
                      )))

         (this.on :copy-channel
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value))
                          (new-channel (e.value.copy)))
                      ((@ new-channel index) (1+ i))
                      ((@ this insert-at) (1+ i) new-channel)
                      ((@ new-channel name) (+ ((@ e.value name)) " ⎘")))))

         (this.on :move-channel-left
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (when (> i 0)
                        (this.swap i (1- i))
                        ((@ ((@ this at) i) index) i)
                        ((@ e.value index) (1- i))))))

         (this.on :move-channel-right
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (when (< i (- this.length 1))
                        (this.swap i (1+ i))
                        ((@ ((@ this at) i) index) i)
                        ((@ e.value index) (1+ i))))))


         (this.on "change:size" (lambda (e)
                                  (this.each (lambda (channel)
                                               ((@ channel size) ((@ this size)))))))
         ))

(defcontainer *Song *Pattern
  init (lambda (&optional
                  (name ((@ options default-song-name)))
                  (tempo ((@ options default-tempo)))
                  (tics-per-beat ((@ options default-tics-per-beat)))
                  (gain ((@ options default-gain)))
                  (pan ((@ options default-pan)))
                  (num-patterns ((@ options default-num-patterns))))
         (this.create 'name name)
         (this.create 'tempo tempo)
         (this.create 'tics-per-beat tics-per-beat)
         (this.create 'gain gain)
         (this.create 'pan pan)
         (this.create 'size num-patterns)
         (dotimes (i ((@ this size)))
           (this.add (new (*Class *Pattern (+ ((@ options default-pattern-name)) " " i)))))

         (this.on :close-pattern
                  (lambda (e)
                    (if (> this.length 1)
                        (this.remove e.value)
                        (alert "I'm sorry Dave, but you can't delete the last pattern."))))
         (this.on :add-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i)
                       (new (*Class *Pattern (+ ((@ options default-pattern-name)) " "
                                                (1+ this.length))))))))
         (this.on :copy-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value))
                          (new-pattern (e.value.copy)))
                      ((@ this insert-at) (1+ i) new-pattern)
                      ((@ new-pattern name) (+ ((@ e.value name)) " ⎘")))))
         (this.on :link-pattern
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      ((@ this insert-at) (1+ i) e.value))))
         (this.on :move-pattern-up
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (> i 0)
                          (this.swap i (1- i))))))
         (this.on :move-pattern-down
                  (lambda (e)
                    (let ((i ((@ this index-of) e.value)))
                      (if (< i (- this.length 1))
                          (this.swap i (1+ i))))))
         ))

(defcontainer *App *Song
  init (lambda ()
         (this.create 'song (new (*Class *Song)))
         ((@ this add) ((@ this song)))
         ))

         

(load "common-views.ps")
(load "note-view.ps")
(load "channel-view.ps")
(load "pattern-view.ps")
(load "song-view.ps")
(load "tools-view.ps")

(defview *Minibuffer-view
    model "app"
    render (lambda ()
             ((@ this $el html) "<input class='MinibufferEditorView' type='text'>")))

(defview *App-view
    model "app"
    contains '*Song-view
    init (lambda (model)
           (this.create 'minibuffer (new (*View *Minibuffer-view this.app)))
           (this.create 'tools (new (*View *Tools-view this.app)))
           (this.create 'song (new (*View *Song-view ((@ this app song))))))
    render (lambda ()
             (let ((html (array
                          (@ ((@ this song)) $el)
                          (@ ((@ this tools)) $el)
                          (@ ((@ this minibuffer)) $el))))
               ((@ this $el html) html))))

(defvar options (new (*Class *Options)))
(defvar app (new (*Class *App)))

((@ ($ document) ready)
 (lambda ()
   (let ((app-view (new (*View *App-view app))))
     ((@ ($ 'body) html) (@ app-view $el))
     ((@ ($ document) bind) 'click (lambda (e)
                                     (unless (or (= (@ e target tag-name) "INPUT")
                                                 (= (@ e target tag-name) "TEXTAREA"))
                                       ((@ ($ ".MinibufferEditorView") select))))))))
;     ((@ ($ document) bind) 'keydown (lambda (e)
;                                       (console.log (@ e char-code))))
   
